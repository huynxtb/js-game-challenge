#!/usr/bin/env node
// Chrono Custodians - A time-traveling text-based game
// Author: Generated by ChatGPT

const readline = require('readline');

class Game {
  constructor() {
    this.maxCycles = 20; // max time cycles allowed
    this.currentCycle = 1;
    this.temporalEnergyMax = 100;
    this.temporalEnergy = this.temporalEnergyMax;
    this.anomalies = [];
    this.anomalyIdCounter = 1;
    this.maxAnomalies = 5; // Max concurrent anomalies before timeline collapse
    this.timelineIntegrity = 100; // Represents timeline health, depletes if anomalies persist
    this.timelineIntegrityWarningThreshold = 40;
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    this.gameOver = false;
    this.win = false;
    this.history = [];
  }

  start() {
    console.clear();
    this.printIntro();
    this.initAnomalies();
    this.mainLoop();
  }

  printIntro() {
    console.log(`\n--- Chrono Custodians ---\n`);
    console.log("You are a time-traveling guardian tasked with preserving the timeline from anomalies caused by rogue time travelers.");
    console.log("Protect the timeline by identifying and neutralizing time anomalies before they cause irreversible changes.");
    console.log(`You have a limited amount of Temporal Energy to investigate and neutralize anomalies within ${this.maxCycles} time cycles.`);
    console.log("If too many anomalies persist or you run out of energy, the timeline will collapse. Good luck!\n");
  }

  initAnomalies() {
    // Start with 2-3 anomalies already present
    const startCount = this.randomInt(2,3);
    for(let i=0; i < startCount; i++) {
      this.spawnAnomaly();
    }
  }

  randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  spawnAnomaly() {
    if(this.anomalies.length >= this.maxAnomalies) return; // can't exceed max anomalies

    const periods = ['Ancient Era', 'Medieval Era', 'Industrial Revolution', 'Modern Day', 'Future'];
    const effects = [
      'Temporal Rift',
      'Paradox Event',
      'Causal Disruption',
      'Time Echo',
      'Continuity Shock'
    ];

    const anomaly = {
      id: this.anomalyIdCounter++,
      period: periods[this.randomInt(0, periods.length -1)],
      effect: effects[this.randomInt(0, effects.length -1)],
      severity: this.randomInt(1,3), // severity 1-3, higher requires more energy to neutralize
      discovered: false,
      investigated: false,
      contained: false
    };

    this.anomalies.push(anomaly);
    this.history.push(`New anomaly detected in the ${anomaly.period}: ${anomaly.effect} (Severity ${anomaly.severity})`);
  }

  printStatus() {
    console.clear();
    console.log(`\n--- Chrono Custodians --- Cycle ${this.currentCycle} of ${this.maxCycles}`);
    console.log(`Temporal Energy: ${this.temporalEnergy}/${this.temporalEnergyMax}`);
    console.log(`Timeline Integrity: ${this.timelineIntegrity}/100`);
    console.log(`Active Anomalies: ${this.anomalies.filter(a => !a.contained).length} (Max allowed: ${this.maxAnomalies})\n`);

    if(this.timelineIntegrity <= this.timelineIntegrityWarningThreshold) {
      console.log("WARNING: Timeline integrity is critically low! Prioritize anomaly containment!\n");
    }

    if(this.anomalies.length === 0 || this.anomalies.every(a => a.contained)) {
      console.log("No active anomalies detected. The timeline is stable for now.\n");
    } else {
      console.log("Known Anomalies:");
      this.anomalies.forEach((a) => {
        if(!a.contained) {
          const status = a.investigated ? 'Investigated' : (a.discovered ? 'Discovered' : 'Unknown');
          let details = `#${a.id} - Period: ${a.period}, Effect: ${a.effect}, Severity: ${a.severity}, Status: ${status}`;
          console.log(details);
        }
      });
      console.log();
    }
  }

  async mainLoop() {
    while(!this.gameOver && !this.win) {
      this.printStatus();

      // Random chance for a new anomaly to spawn each cycle
      if(this.anomalies.length < this.maxAnomalies && Math.random() < 0.35) {
        this.spawnAnomaly();
        console.log("[Alert] A new time anomaly has appeared in the timeline!");
      }

      // Provide options to player
      await this.playerTurn();

      // Resolve consequences at the end of cycle
      this.endOfCycle();

      if(this.checkWinCondition()) {
        this.win = true;
        break;
      }

      if(this.checkLossCondition()) {
        this.gameOver = true;
        break;
      }

      this.currentCycle++;
      if(this.currentCycle > this.maxCycles) {
        // Ran out of time to resolve anomalies
        this.gameOver = true;
      }
    }

    this.printStatus();
    if(this.win) {
      console.log("\n*** Congratulations! You have successfully preserved the timeline. ***");
    } else {
      console.log("\n*** Timeline collapse! The irreversible damage caused the end of history as we know it. ***");
    }

    this.rl.close();
  }

  async playerTurn() {
    console.log("Choose an action:");
    console.log("1) Investigate an anomaly (Costs 10 Temporal Energy)");
    console.log("2) Travel to anomaly period to contain it (Costs energy based on severity)");
    console.log("3) Skip turn to conserve energy");
    console.log("4) View history log");

    const answer = await this.askPrompt("Your choice (1-4): ");
    switch(answer) {
      case '1':
        await this.actionInvestigate();
        break;
      case '2':
        await this.actionContain();
        break;
      case '3':
        console.log("You conserve Temporal Energy this cycle.");
        break;
      case '4':
        this.printHistoryLog();
        await this.askPrompt("Press ENTER to continue...");
        await this.playerTurn(); // recall choices after viewing log
        break;
      default:
        console.log("Invalid choice. Please select between 1 and 4.");
        await this.playerTurn();
        break;
    }
  }

  printHistoryLog() {
    console.log("\n--- Timeline Event Log ---");
    if(this.history.length === 0) {
      console.log("No notable events logged yet.");
    } else {
      this.history.forEach((event, i) => {
        console.log(`${i+1}. ${event}`);
      });
    }
    console.log();
  }

  async actionInvestigate() {
    if(this.temporalEnergy < 10) {
      console.log("Insufficient Temporal Energy to investigate anomalies.");
      return;
    }
    const undiscovered = this.anomalies.filter(a => !a.discovered && !a.contained);
    if(undiscovered.length === 0) {
      console.log("No unknown anomalies to investigate.");
      return;
    }
    console.log("Choose an anomaly to investigate:");
    undiscovered.forEach((a, idx) => {
      console.log(`${idx+1}) Unknown anomaly in unknown period, Effect and Severity unknown`);
    });
    const ans = await this.askPrompt(`Choose 1-${undiscovered.length} or 0 to cancel: `);
    const idx = parseInt(ans) - 1;
    if(ans === '0') {
      return;
    }
    if(idx >=0 && idx < undiscovered.length) {
      this.temporalEnergy -= 10;
      const anomaly = undiscovered[idx];
      anomaly.discovered = true;
      anomaly.investigated = true;
      this.history.push(`Investigated anomaly #${anomaly.id} in ${anomaly.period}: Effect "${anomaly.effect}", Severity ${anomaly.severity}`);
      console.log(`Investigated anomaly: Period: ${anomaly.period}, Effect: ${anomaly.effect}, Severity: ${anomaly.severity}`);
    } else {
      console.log("Invalid choice.");
      await this.actionInvestigate();
    }
  }

  async actionContain() {
    if(this.anomalies.filter(a => a.discovered && !a.contained).length === 0) {
      console.log("No known anomalies to contain. Investigate anomalies first.");
      return;
    }
    const candidates = this.anomalies.filter(a => a.discovered && !a.contained);
    console.log("Choose an anomaly to attempt containment:");
    candidates.forEach((a, idx) => {
      console.log(`${idx+1}) #${a.id} Period: ${a.period}, Effect: ${a.effect}, Severity: ${a.severity}`);
    });
    const ans = await this.askPrompt(`Choose 1-${candidates.length} or 0 to cancel: `);
    const idx = parseInt(ans) - 1;
    if(ans === '0') {
      return;
    }
    if(idx >= 0 && idx < candidates.length) {
      const anomaly = candidates[idx];
      const energyCost = anomaly.severity * 15;
      if(this.temporalEnergy < energyCost) {
        console.log(`Insufficient Temporal Energy to contain anomaly #${anomaly.id} (cost: ${energyCost}).`);
        return;
      }
      this.temporalEnergy -= energyCost;
      // Attempt containment success chance based on severity (higher severity, lower chance)
      let successChance = 0.8 - (anomaly.severity - 1) * 0.25; // Severity 1=80%, 2=55%, 3=30%
      let randomVal = Math.random();
      if(randomVal < successChance) {
        anomaly.contained = true;
        this.history.push(`Successfully contained anomaly #${anomaly.id} in ${anomaly.period}.`);
        console.log(`Containment successful! Anomaly #${anomaly.id} neutralized.`);
      } else {
        this.history.push(`Containment attempt failed on anomaly #${anomaly.id}.`);
        console.log(`Containment failed! The anomaly persists and worsens.`);
        // Failed containment worsens timeline integrity and may increase severity
        this.timelineIntegrity -= 5 * anomaly.severity;
        if(Math.random() < 0.3 && anomaly.severity < 3) {
          anomaly.severity++;
          console.log(`The anomaly's severity has increased to ${anomaly.severity}!`);
          this.history.push(`Anomaly #${anomaly.id} severity increased to ${anomaly.severity}.`);
        }
      }
    } else {
      console.log("Invalid choice.");
      await this.actionContain();
    }
  }

  endOfCycle() {
    // Anomalies that are not contained gradually reduce timeline integrity
    let activeAnomalies = this.anomalies.filter(a => !a.contained);
    if(activeAnomalies.length > 0) {
      let integrityLoss = 0;
      activeAnomalies.forEach(a => {
        integrityLoss += a.severity * 3;
      });
      this.timelineIntegrity -= integrityLoss;
      this.history.push(`Timeline integrity reduced by ${integrityLoss} due to persistent anomalies.`);
      if(this.timelineIntegrity < 0) this.timelineIntegrity = 0;
    }

    // Small chance some anomalies collapse or disappear on their own
    this.anomalies.forEach((a) => {
      if(!a.contained && Math.random() < 0.1) {
        a.contained = true;
        this.history.push(`Anomaly #${a.id} dissipated naturally this cycle.`);
      }
    });

    // Regenerate small amount of Temporal Energy per cycle (simulate recharge)
    let regen = 5;
    this.temporalEnergy += regen;
    if(this.temporalEnergy > this.temporalEnergyMax) this.temporalEnergy = this.temporalEnergyMax;
  }

  checkWinCondition() {
    // Win if all anomalies contained and timeline integrity is good
    if(this.anomalies.every(a => a.contained) && this.timelineIntegrity > 0) {
      return true;
    }
    return false;
  }

  checkLossCondition() {
    if(this.timelineIntegrity <= 0) {
      return true;
    }
    if(this.temporalEnergy <= 0 && this.anomalies.some(a => !a.contained)) {
      // No energy left but anomalies remain
      return true;
    }
    if(this.anomalies.filter(a => !a.contained).length > this.maxAnomalies) {
      return true; // Too many anomalies
    }
    return false;
  }

  askPrompt(query) {
    return new Promise(resolve => {
      this.rl.question(query, (ans) => {
        resolve(ans.trim());
      });
    });
  }
}

// Run game
const game = new Game();
game.start();
